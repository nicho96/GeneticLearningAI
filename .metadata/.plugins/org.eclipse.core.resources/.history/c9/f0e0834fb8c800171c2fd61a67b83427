package ca.nicho.nerual;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;

import ca.nicho.Board;
import ca.nicho.neat.DefaultNEAT;
import ca.nicho.neuralnet.Layer;
import ca.nicho.neuralnet.NeuralNetwork;
import ca.nicho.neuralnet.Neuron;
import ca.nicho.neuralnet2.neat2.DefaultNEAT2;

public class NeuralEvolver {

	public static final File DIR_PATH = new File("networks");

	public static final int BOARD_SIZE = 16;
	
	private Random random = new Random();
	
	private int neuronCount;
	private int axonCount;
	
	public NeuralEvolver(){
		
		
		DefaultNEAT2 neat = new DefaultNEAT2(BOARD_SIZE * BOARD_SIZE, 3, delegate);

		int generation = 0;
		while(true){
			generation++;
			System.out.println("==== 2048 Current Generation: " + generation + " ====");
			neat.nextGeneration();
			this.save(neat.getMaxNetwork());
		}
				
	}
	
	private DefaultNEAT.SimulateDelegate delegate = (NeuralNetwork network) -> {
		NetworkController c = new SimpleNetworkController(network, new Board(null));
		c.simulate();
	};
	
	private void save(NeuralNetwork nn){
		File f = new File(DIR_PATH, "test3.dat");
		if(!f.exists()){
			f.getParentFile().mkdirs();
			try {
				f.createNewFile();
			} catch (IOException e) {
				System.out.println(e.getMessage());
				return;
			}
		}
		nn.save(f);
	}
	
	public void preprateInputs(NeuralNetwork network){
		for(int i = 0; i < network.inputs.length; i++){
			network.inputs[i] = network.createNeuron(network.layers.get(0), neuronCount++);
		}
	}
	
	public void preprateOutputs(NeuralNetwork network){
		for(int i = 0; i < network.outputs.length; i++){
			network.outputs[i] = network.createNeuron(network.outputLayer, neuronCount++);
		}
	}
	
	public boolean randomNeuronConnection(NeuralNetwork nn){	
		
		//Get the non-empty layers from the array
		ArrayList<Layer> possibilities = new ArrayList<Layer>();
		for(Layer l : nn.layers){
			if(l.neurons.size() > 0){
				possibilities.add(l);
			}
		}
		
		//There are not two layers available to create a random neuron connection
		if(possibilities.size() < 2){
			return false;
		}
		
		//Get a split index
		int splitIndex = random.nextInt(possibilities.size() - 1);
		
		//Get neurons before the split
		ArrayList<Neuron> left = new ArrayList<Neuron>();
		for(int i = 0; i <= splitIndex; i++){
			for(Neuron n : possibilities.get(i).neurons){
				left.add(n);
			}
		}
		
		//Get neurons after the split
		ArrayList<Neuron> right = new ArrayList<Neuron>();
		for(int i = splitIndex + 1; i < possibilities.size(); i++){
			for(Neuron n : possibilities.get(i).neurons){
				right.add(n);
			}
		}
		
		Neuron n1 = left.get(random.nextInt(left.size()));
		Neuron n2 = right.get(random.nextInt(right.size()));
		nn.connectNeurons(n1, n2, random.nextDouble() * 2 - 1, axonCount++);
		
		return true;
		
	}
		
}
