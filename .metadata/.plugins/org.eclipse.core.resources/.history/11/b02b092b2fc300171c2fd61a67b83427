package ca.nicho.nerual;

import java.util.ArrayList;
import java.util.Random;

import ca.nicho.Board;
import ca.nicho.neuralnet.DefaultNEAT;
import ca.nicho.neuralnet.Layer;
import ca.nicho.neuralnet.NeuralNetwork;
import ca.nicho.neuralnet.Neuron;
import ca.nicho.neuralnet.Population;

public class NeuralEvolver {

	public static final int BOARD_SIZE = 16;
	
	private Random random = new Random();
	
	private int neuronCount;
	private int axonCount;
	
	public NeuralEvolver(){
		//Used for complex
		//NeuralNetwork origin = new NeuralNetwork(BOARD_SIZE * BOARD_SIZE, 4, 1);		
		
		//Used for simple
		NeuralNetwork origin = new NeuralNetwork(BOARD_SIZE, 4, 1);
		
		Population p = new Population(100, origin, delegate);
		while(true){
			p.simulateGeneration();
		}
				
	}
	
	private DefaultNEAT.SimulateDelegate delegate = (NeuralNetwork network) -> {
		double min = -1;
		for(int i = 0; i < 20; i++){
			NetworkController c = new SimpleNetworkController(network, new Board(null));
			c.simulate();
			double score = c.moveCount - 0.25 * c.failedMoves;
			if(min == -1 || min > score){
				min = score;
			}
		}
		network.score = (int)min;
	};
	
	public void preprateInputs(NeuralNetwork network){
		for(int i = 0; i < network.inputs.length; i++){
			network.inputs[i] = network.createNeuron(network.layers.get(0), neuronCount++);
		}
	}
	
	public void preprateOutputs(NeuralNetwork network){
		for(int i = 0; i < network.outputs.length; i++){
			network.outputs[i] = network.createNeuron(network.outputLayer, neuronCount++);
		}
	}
	
	public boolean randomNeuronConnection(NeuralNetwork nn){	
		
		//Get the non-empty layers from the array
		ArrayList<Layer> possibilities = new ArrayList<Layer>();
		for(Layer l : nn.layers){
			if(l.neurons.size() > 0){
				possibilities.add(l);
			}
		}
		
		//There are not two layers available to create a random neuron connection
		if(possibilities.size() < 2){
			return false;
		}
		
		//Get a split index
		int splitIndex = random.nextInt(possibilities.size() - 1);
		
		//Get neurons before the split
		ArrayList<Neuron> left = new ArrayList<Neuron>();
		for(int i = 0; i <= splitIndex; i++){
			for(Neuron n : possibilities.get(i).neurons){
				left.add(n);
			}
		}
		
		//Get neurons after the split
		ArrayList<Neuron> right = new ArrayList<Neuron>();
		for(int i = splitIndex + 1; i < possibilities.size(); i++){
			for(Neuron n : possibilities.get(i).neurons){
				right.add(n);
			}
		}
		
		Neuron n1 = left.get(random.nextInt(left.size()));
		Neuron n2 = right.get(random.nextInt(right.size()));
		nn.connectNeurons(n1, n2, random.nextDouble() * 2 - 1, axonCount++);
		
		return true;
		
	}
		
}
